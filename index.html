<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>çŒ«ç ‚æ·˜æ·˜ä¹</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body {
  width:100%; height:100%;
  background:#1a1008;
  display:flex; align-items:center; justify-content:center;
  overflow:hidden;
  touch-action:none;
  user-select:none;
  font-family:'PingFang SC','Microsoft YaHei',sans-serif;
}
#wrap {
  position:relative;
  width:min(420px, 100vw);
  height:min(780px, 100dvh);
  overflow:hidden;
  background:#c8a050;
}

/* canvas stack - all absolute, same size */
#layer-sand    { position:absolute; inset:0; z-index:1; }
#layer-turds   { position:absolute; inset:0; z-index:2; }
#layer-mask    { position:absolute; inset:0; z-index:3; }
#layer-fx      { position:absolute; inset:0; z-index:4; pointer-events:none; }

/* UI on top */
#ui {
  position:absolute; inset:0; z-index:10;
  pointer-events:none;
  display:flex; flex-direction:column;
  justify-content:space-between;
}

/* top bar */
#topbar {
  pointer-events:all;
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 14px 8px;
  background:linear-gradient(to bottom, rgba(0,0,0,.55) 60%, transparent);
}
#score-wrap { color:#f5c842; }
#score-label { font-size:9px; letter-spacing:3px; opacity:.6; }
#score-num { font-size:26px; font-weight:900; line-height:1.1; }

#sift-btn {
  pointer-events:all;
  width:72px; height:72px;
  border-radius:50%;
  background:linear-gradient(145deg,#f5c842,#e0a020);
  border:none;
  font-size:28px;
  box-shadow:0 4px 20px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.3);
  cursor:pointer;
  active-scale:.92;
  transition:transform .1s, box-shadow .1s;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:0;
}
#sift-btn:active { transform:scale(.92); box-shadow:0 2px 8px rgba(0,0,0,.4); }
#sift-btn .btn-icon { font-size:28px; line-height:1; }
#sift-btn .btn-label { font-size:9px; font-weight:700; color:#7a4000; letter-spacing:1px; }

#combo-wrap {
  min-width:70px; text-align:right;
  font-size:13px; font-weight:800; color:#ff8844;
}

/* bottom tray */
#tray {
  pointer-events:none;
  padding:8px 10px 16px;
  background:linear-gradient(to top, rgba(0,0,0,.9) 60%, transparent);
}
#tray-label {
  font-size:9px; color:rgba(255,255,255,.3);
  letter-spacing:3px; text-align:center; margin-bottom:6px;
}
#slots {
  display:flex; gap:5px; justify-content:center;
}
.slot {
  width:46px; height:54px;
  border-radius:10px;
  background:rgba(255,255,255,.06);
  border:1.5px solid rgba(255,255,255,.12);
  display:flex; align-items:center; justify-content:center;
  font-size:26px; flex-shrink:0;
}
.slot.has-item { animation:slotpop .22s cubic-bezier(.17,.67,.35,1.5); }
@keyframes slotpop{0%{transform:scale(0) rotate(-10deg)}100%{transform:scale(1)}}
.slot.match-flash { animation:matchflash .4s ease; }
@keyframes matchflash{0%{background:rgba(245,200,66,.7);transform:scale(1.18)}100%{transform:scale(1)}}

/* overlays */
#burst {
  display:none; position:absolute; z-index:20; pointer-events:none;
  font-size:28px; font-weight:900; color:#f5c842;
  text-shadow:0 0 24px rgba(245,200,66,.9);
  text-align:center; white-space:nowrap;
}
@keyframes burstpop{
  0%{transform:translate(-50%,-50%) scale(0);opacity:0}
  45%{transform:translate(-50%,-50%) scale(1.25);opacity:1}
  100%{transform:translate(-50%,-50%) scale(1);opacity:0}
}
.ft {
  position:absolute; pointer-events:none; z-index:20;
  font-weight:900; animation:ftup .75s ease forwards;
}
@keyframes ftup{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-60px);opacity:0}}

#gameover {
  display:none; position:absolute; inset:0; z-index:50;
  background:rgba(0,0,0,.85); backdrop-filter:blur(6px);
  flex-direction:column; align-items:center; justify-content:center; gap:14px;
}
#gameover.show { display:flex; }
#gameover h2 { font-size:34px; color:#f5c842; }
#gameover p  { font-size:15px; color:#c8a060; }
#restart-btn {
  padding:13px 36px; background:#f5c842; color:#1a0e00;
  border:none; border-radius:50px; font-size:17px; font-weight:800; cursor:pointer;
}

/* hint toast */
#hint-toast {
  position:absolute; bottom:100px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,.6); color:#fff; border-radius:20px;
  padding:6px 16px; font-size:12px; pointer-events:none;
  z-index:15; opacity:0; transition:opacity .3s;
  white-space:nowrap;
}
#hint-toast.show { opacity:1; }
</style>
</head>
<body>
<div id="wrap">
  <!-- canvas layers -->
  <canvas id="layer-sand"></canvas>
  <canvas id="layer-turds"></canvas>
  <canvas id="layer-mask"></canvas>
  <canvas id="layer-fx"></canvas>

  <div id="ui">
    <div id="topbar">
      <div id="score-wrap">
        <div id="score-label">SCORE</div>
        <div id="score-num">0</div>
      </div>
      <button id="sift-btn" onclick="sift()">
        <span class="btn-icon">ğŸ¾</span>
        <span class="btn-label">é“²ä¸€é“²</span>
      </button>
      <div id="combo-wrap"></div>
    </div>

    <div id="tray">
      <div id="tray-label">æ”¶é›†æ§½ Â· 7 SLOTS</div>
      <div id="slots"></div>
    </div>
  </div>

  <div id="burst"></div>
  <div id="hint-toast"></div>

  <div id="gameover">
    <h2>ğŸ’© æ§½ä½å·²æ»¡ï¼</h2>
    <p id="go-score">æœ€ç»ˆå¾—åˆ†: 0</p>
    <button id="restart-btn" onclick="initGame()">å†æ¥ä¸€å±€ ğŸ”„</button>
  </div>
</div>

<script>
// â”€â”€ TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TYPES = [
  { emoji:'ğŸ’©', color:'#8B4513', dark:'#5a2a08' },
  { emoji:'ğŸŸ¤', color:'#A0522D', dark:'#6b3018' },
  { emoji:'ğŸ«˜', color:'#6B3A2A', dark:'#3d1a10' },
  { emoji:'âš«', color:'#2d2018', dark:'#0a0806' },
  { emoji:'â­', color:'#B8860B', dark:'#7a5500' },
];

// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const N_TURDS   = 18;    // total turds in the sandbox
const MAX_SLOTS = 7;
const TRAY_H    = 82;    // px, must match CSS roughly
const TOPBAR_H  = 80;
const REVEAL_PER_SIFT = 3;   // how many turds get unburied per sift
const BURY_THRESHOLD  = 0.35; // below this depth = can be tapped

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let W, H;
let cSand, ctxSand;
let cTurds, ctxTurds;
let cMask, ctxMask;
let cFx, ctxFx;

let turds = [];
let slots = [];
let score = 0, combo = 0;
let gameOver = false;
let particles = [];
let sandNoise = [];
let frameCount = 0;
let siftAnim = 0;      // > 0 means sifting animation is playing
let lastMotionSift = 0;

const wrap     = document.getElementById('wrap');
const scoreEl  = document.getElementById('score-num');
const comboEl  = document.getElementById('combo-wrap');
const slotsEl  = document.getElementById('slots');
const burstEl  = document.getElementById('burst');
const hintEl   = document.getElementById('hint-toast');

// â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize() {
  W = wrap.clientWidth;
  H = wrap.clientHeight;
  for (const id of ['layer-sand','layer-turds','layer-mask','layer-fx']) {
    const c = document.getElementById(id);
    c.width = W; c.height = H;
  }
}

function getCtxs() {
  cSand  = document.getElementById('layer-sand');   ctxSand  = cSand.getContext('2d');
  cTurds = document.getElementById('layer-turds');  ctxTurds = cTurds.getContext('2d');
  cMask  = document.getElementById('layer-mask');   ctxMask  = cMask.getContext('2d');
  cFx    = document.getElementById('layer-fx');     ctxFx    = cFx.getContext('2d');
}

// â”€â”€ TURD CREATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeTurds() {
  turds = [];
  const playW = W;
  const playH = H - TRAY_H - TOPBAR_H;
  const margin = 40;

  // simple grid scatter to avoid overlap
  for (let i = 0; i < N_TURDS; i++) {
    let placed = false, tries = 0, x, y, r;
    r = 18 + Math.random() * 10;
    while (!placed && tries < 80) {
      x = margin + Math.random() * (playW - margin*2);
      y = TOPBAR_H + margin + Math.random() * (playH - margin*2);
      // check no overlap
      let ok = true;
      for (const t of turds) {
        if (Math.hypot(t.x - x, t.y - y) < t.r + r + 8) { ok=false; break; }
      }
      if (ok) placed = true;
      tries++;
    }
    turds.push({
      typeId: i % TYPES.length,
      x, y, r,
      angle: Math.random() * Math.PI * 2,
      depth: 1.0,        // 1 = fully buried, 0 = fully revealed
      targetDepth: 1.0,
      collected: false,
    });
  }
  // shuffle typeIds for variety
  for (let i = turds.length-1; i>0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [turds[i].typeId, turds[j].typeId] = [turds[j].typeId, turds[i].typeId];
  }
}

// â”€â”€ SAND NOISE MAP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeSandNoise() {
  sandNoise = [];
  const cols = Math.ceil(W / 8) + 2;
  const rows = Math.ceil(H / 8) + 2;
  for (let r = 0; r < rows; r++) {
    sandNoise.push([]);
    for (let c = 0; c < cols; c++) {
      sandNoise[r].push(Math.random());
    }
  }
}

// â”€â”€ DRAW: SAND LAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// drawn once, redrawn on sift
function drawSand(shake = 0) {
  const ctx = ctxSand;
  ctx.clearRect(0, 0, W, H);

  // base color
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,   '#d4aa60');
  g.addColorStop(0.5, '#c09040');
  g.addColorStop(1,   '#a07030');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // grain dots
  const cellW = 8, cellH = 8;
  for (let r = 0; r < sandNoise.length; r++) {
    for (let c = 0; c < sandNoise[r].length; c++) {
      const v = sandNoise[r][c];
      const dx = shake * (Math.random()-.5) * 4;
      const dy = shake * (Math.random()-.5) * 4;
      const px = c * cellW + dx;
      const py = r * cellH + dy;
      if (v > 0.6) {
        ctx.fillStyle = `rgba(255,220,120,${(v-0.6)*1.8})`;
        ctx.fillRect(px, py, 2, 2);
      } else if (v < 0.25) {
        ctx.fillStyle = `rgba(80,45,10,${(0.25-v)*2})`;
        ctx.fillRect(px, py, 2, 2);
      }
    }
  }

  // subtle ripple lines (like raked sand)
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#7a5010';
  ctx.lineWidth = 1;
  for (let y = 0; y < H; y += 14) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    for (let x = 0; x < W; x += 20) {
      ctx.lineTo(x + 10, y + 3 + Math.sin(x*0.05)*2);
      ctx.lineTo(x + 20, y);
    }
    ctx.stroke();
  }
  ctx.restore();
}

// â”€â”€ DRAW: TURDS LAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTurds() {
  const ctx = ctxTurds;
  ctx.clearRect(0, 0, W, H);

  for (const t of turds) {
    if (t.collected) continue;
    drawOneTurd(ctx, t);
  }
}

function drawOneTurd(ctx, t) {
  const { x, y, r, angle, typeId } = t;
  const type = TYPES[typeId];

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // drop shadow
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowBlur  = 10;
  ctx.shadowOffsetY = 4;

  // body gradient
  const gr = ctx.createRadialGradient(-r*.3,-r*.35,r*.05, 0,0,r*1.1);
  gr.addColorStop(0,   lighten(type.color, 50));
  gr.addColorStop(0.5, type.color);
  gr.addColorStop(1,   type.dark);
  ctx.fillStyle = gr;

  ctx.beginPath();
  drawShape(ctx, typeId, r);
  ctx.fill();

  ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

  // shine
  ctx.beginPath();
  ctx.ellipse(-r*.22, -r*.28, r*.24, r*.16, -.5, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,.32)';
  ctx.fill();

  // emoji
  ctx.font = `${r * 1.05}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = 0.85;
  ctx.shadowBlur = 0;
  ctx.fillText(type.emoji, 0, 1);

  ctx.restore();
}

function drawShape(ctx, typeId, r) {
  switch(typeId) {
    case 0: // poop swirl
      ctx.moveTo(0, r);
      ctx.bezierCurveTo(r*1.1,r*0.8, r*1.1,-r*0.2, r*0.4,-r*0.3);
      ctx.bezierCurveTo(r*0.9,-r*0.7, r*0.4,-r*1.1, 0,-r);
      ctx.bezierCurveTo(-r*0.4,-r*1.1, -r*0.9,-r*0.7, -r*0.4,-r*0.3);
      ctx.bezierCurveTo(-r*1.1,-r*0.2, -r*1.1,r*0.8, 0,r);
      break;
    case 1: // round
      ctx.arc(0, 0, r, 0, Math.PI*2);
      break;
    case 2: // bean
      ctx.ellipse(0, 0, r*0.72, r, 0.3, 0, Math.PI*2);
      break;
    case 3: // nugget
      for(let i=0;i<8;i++){
        const a=(i/8)*Math.PI*2-Math.PI/2;
        const ir=r*(.68+Math.sin(i*2.1)*.22);
        i===0?ctx.moveTo(Math.cos(a)*ir,Math.sin(a)*ir):ctx.lineTo(Math.cos(a)*ir,Math.sin(a)*ir);
      }
      ctx.closePath();
      break;
    case 4: // star
      for(let i=0;i<5;i++){
        const a=(i/5)*Math.PI*2-Math.PI/2, ia=a+Math.PI/5;
        i===0?ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r):ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);
        ctx.lineTo(Math.cos(ia)*r*.42,Math.sin(ia)*r*.42);
      }
      ctx.closePath();
      break;
  }
}

// â”€â”€ DRAW: MASK LAYER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// The mask is a full-screen sand-colored fill.
// We "punch holes" where turds are revealed, using destination-out.
function drawMask(shake = 0) {
  const ctx = ctxMask;
  ctx.clearRect(0, 0, W, H);

  // full sand overlay
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,   '#d4aa60');
  g.addColorStop(0.5, '#c09040');
  g.addColorStop(1,   '#a07030');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // grain on mask too (for texture consistency)
  ctx.save();
  ctx.globalAlpha = 0.18;
  for (let r = 0; r < sandNoise.length; r++) {
    for (let c = 0; c < sandNoise[r].length; c++) {
      const v = sandNoise[r][c];
      const dx = shake * (Math.random()-.5)*6;
      const dy = shake * (Math.random()-.5)*6;
      if (v > 0.62) {
        ctx.fillStyle = 'rgba(255,220,120,1)';
        ctx.fillRect(c*8+dx, r*8+dy, 2, 2);
      } else if (v < 0.22) {
        ctx.fillStyle = 'rgba(60,30,5,1)';
        ctx.fillRect(c*8+dx, r*8+dy, 2, 2);
      }
    }
  }
  ctx.restore();

  // punch holes for revealed turds
  ctx.globalCompositeOperation = 'destination-out';
  for (const t of turds) {
    if (t.collected || t.depth >= 1.0) continue;
    const revealR = t.r * (1.0 - t.depth) * 1.6;
    if (revealR < 1) continue;

    // soft-edged hole: radial gradient alpha
    const holeGrad = ctx.createRadialGradient(t.x, t.y, revealR*0.3, t.x, t.y, revealR);
    holeGrad.addColorStop(0,   'rgba(0,0,0,1)');
    holeGrad.addColorStop(0.7, 'rgba(0,0,0,0.85)');
    holeGrad.addColorStop(1,   'rgba(0,0,0,0)');

    ctx.beginPath();
    ctx.arc(t.x, t.y, revealR, 0, Math.PI*2);
    ctx.fillStyle = holeGrad;
    ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
}

// â”€â”€ SIFT ACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sift() {
  if (gameOver) return;

  siftAnim = 1.0;  // triggers shake animation
  if (navigator.vibrate) navigator.vibrate(40);

  // scatter sand noise for variety
  for (const row of sandNoise) {
    for (let i = 0; i < row.length; i++) {
      if (Math.random() < 0.3) row[i] = Math.random();
    }
  }

  // pick buried turds to reveal
  const buried = turds.filter(t => !t.collected && t.depth > BURY_THRESHOLD);
  // shuffle
  buried.sort(() => Math.random()-.5);

  const toReveal = Math.min(REVEAL_PER_SIFT, buried.length);
  for (let i = 0; i < toReveal; i++) {
    // reduce depth gradually â€” won't fully reveal in one sift
    buried[i].targetDepth = Math.max(0, buried[i].depth - (0.35 + Math.random()*0.35));
  }

  // spawn sand dust particles
  for (let i = 0; i < 25; i++) {
    particles.push({
      x: Math.random() * W,
      y: TOPBAR_H + Math.random() * (H - TOPBAR_H - TRAY_H),
      vx: (Math.random()-.5) * 5,
      vy: (Math.random()-.5) * 5,
      r:  2 + Math.random() * 4,
      life: 1,
      color: `hsl(${30+Math.random()*20},${50+Math.random()*20}%,${40+Math.random()*20}%)`,
    });
  }
}

// â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  frameCount++;

  // animate sift shake
  if (siftAnim > 0) siftAnim = Math.max(0, siftAnim - 0.07);

  // smooth depth animation
  for (const t of turds) {
    if (t.collected) continue;
    if (t.depth > t.targetDepth) {
      t.depth = Math.max(t.targetDepth, t.depth - 0.025);
    }
  }

  // particles
  for (let i = particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.88; p.vy *= 0.88;
    p.life -= 0.035;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  const shake = siftAnim * 5;

  // 1. sand base (only redraw when sifting for perf)
  if (siftAnim > 0.05 || frameCount < 3) {
    drawSand(siftAnim);
  }

  // 2. turds (always, for depth animation)
  drawTurds();

  // 3. mask with holes
  drawMask(siftAnim);

  // 4. fx: particles + shake offset
  ctxFx.clearRect(0, 0, W, H);
  if (siftAnim > 0.05) {
    // screen shake: draw a dark flash overlay
    ctxFx.fillStyle = `rgba(0,0,0,${siftAnim * 0.08})`;
    ctxFx.fillRect(0, 0, W, H);
  }
  for (const p of particles) {
    ctxFx.globalAlpha = p.life;
    ctxFx.beginPath();
    ctxFx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctxFx.fillStyle = p.color;
    ctxFx.fill();
  }
  ctxFx.globalAlpha = 1;
}

// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  requestAnimationFrame(loop);
  update();
  render();
}

// â”€â”€ COLLECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tryCollect(px, py) {
  if (gameOver) return;

  let best = null, bestD = Infinity;
  for (const t of turds) {
    if (t.collected) continue;
    if (t.depth > BURY_THRESHOLD) continue; // still too buried

    const d = Math.hypot(t.x - px, t.y - py);
    if (d < t.r * 2.2 && d < bestD) { best = t; bestD = d; }
  }
  if (!best) {
    // show hint if tapped buried area
    for (const t of turds) {
      if (t.collected) continue;
      const d = Math.hypot(t.x - px, t.y - py);
      if (d < t.r * 2) { showHint('å†é“²å‡ æ¬¡å°±å‡ºæ¥äº†ï¼'); break; }
    }
    return;
  }

  best.collected = true;
  if (slots.length >= MAX_SLOTS) { triggerGameOver(); return; }

  slots.push(best.typeId);
  spawnFT(best.x, best.y, '+1', '#f5c842', 14);
  if (navigator.vibrate) navigator.vibrate(15);
  renderSlots();
  checkMatch();
}

// â”€â”€ MATCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkMatch() {
  const counts = {};
  for (const id of slots) counts[id] = (counts[id]||0)+1;
  for (const [id, n] of Object.entries(counts)) {
    if (n >= 3) {
      let rem = 0;
      slots = slots.filter(s => (s===+id && rem<3) ? (rem++, false) : true);
      combo++;
      const pts = 100 * combo;
      score += pts;
      scoreEl.textContent = score;
      comboEl.textContent = combo > 1 ? `Ã—${combo} è¿æ¶ˆ!` : '';
      showBurst(TYPES[+id].emoji, pts);
      spawnParticles(W/2, H - TRAY_H - 30, TYPES[+id].color);
      flashSlots();
      if (navigator.vibrate) navigator.vibrate([30,15,60]);
      renderSlots();
      setTimeout(checkMatch, 260);
      return;
    }
  }
  if (combo > 0 && slots.length < MAX_SLOTS) { combo=0; comboEl.textContent=''; }
}

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getXY(e) {
  const rect = cMask.getBoundingClientRect();
  const sx = W / rect.width, sy = H / rect.height;
  const src = e.touches ? e.touches[0] : e;
  return { x:(src.clientX-rect.left)*sx, y:(src.clientY-rect.top)*sy };
}

// tap on main canvas = try collect
cMask && cMask.addEventListener('touchstart', e=>{
  e.preventDefault();
  const {x,y} = getXY(e);
  // ignore tray and topbar
  if (y < TOPBAR_H || y > H - TRAY_H) return;
  tryCollect(x, y);
}, {passive:false});

// device motion (shake = sift)
if (window.DeviceMotionEvent) {
  window.addEventListener('devicemotion', e => {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const mag = Math.sqrt(a.x**2 + a.y**2 + a.z**2);
    const now = Date.now();
    if (mag > 22 && now - lastMotionSift > 800) {
      lastMotionSift = now;
      sift();
    }
  });
}

// â”€â”€ UI HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSlots() {
  slotsEl.innerHTML = '';
  for (let i = 0; i < MAX_SLOTS; i++) {
    const d = document.createElement('div');
    d.className = 'slot';
    if (slots[i] !== undefined) {
      d.textContent = TYPES[slots[i]].emoji;
      d.classList.add('has-item');
    }
    slotsEl.appendChild(d);
  }
}

function flashSlots() {
  document.querySelectorAll('.slot').forEach(s=>{
    s.classList.remove('match-flash');
    void s.offsetWidth;
    s.classList.add('match-flash');
  });
}

function showBurst(emoji, pts) {
  burstEl.style.cssText = `display:block; left:50%; top:45%; animation:none; transform:translate(-50%,-50%)`;
  burstEl.textContent = `${emoji}Ã—3  +${pts}`;
  void burstEl.offsetWidth;
  burstEl.style.animation = 'burstpop .75s ease forwards';
  setTimeout(()=> burstEl.style.display='none', 850);
}

function spawnFT(x, y, txt, color, size) {
  const el = document.createElement('div');
  el.className = 'ft';
  el.style.cssText = `left:${x}px;top:${y}px;color:${color};font-size:${size}px;transform:translateX(-50%)`;
  el.textContent = txt;
  wrap.appendChild(el);
  setTimeout(()=>el.remove(), 800);
}

function spawnParticles(x, y, color) {
  for (let i=0;i<20;i++) particles.push({
    x, y,
    vx:(Math.random()-.5)*9,
    vy:-(2+Math.random()*7),
    r:3+Math.random()*4,
    life:1, color,
  });
}

function showHint(msg) {
  hintEl.textContent = msg;
  hintEl.classList.add('show');
  clearTimeout(showHint._t);
  showHint._t = setTimeout(()=>hintEl.classList.remove('show'), 1800);
}

function triggerGameOver() {
  gameOver = true;
  document.getElementById('gameover').classList.add('show');
  document.getElementById('go-score').textContent = `æœ€ç»ˆå¾—åˆ†: ${score}`;
}

function lighten(h, a) {
  return `rgb(${Math.min(255,parseInt(h.slice(1,3),16)+a)},${Math.min(255,parseInt(h.slice(3,5),16)+a)},${Math.min(255,parseInt(h.slice(5,7),16)+a)})`;
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initGame() {
  document.getElementById('gameover').classList.remove('show');
  gameOver=false; slots=[]; score=0; combo=0; particles=[];
  scoreEl.textContent='0'; comboEl.textContent='';
  siftAnim=0;

  resize();
  getCtxs();
  makeSandNoise();
  makeTurds();
  renderSlots();

  // Add input listener now that canvas exists
  document.getElementById('layer-mask').addEventListener('touchstart', e=>{
    e.preventDefault();
    const {x,y} = getXY(e);
    if (y < TOPBAR_H || y > H - TRAY_H) return;
    tryCollect(x, y);
  }, {passive:false});

  document.getElementById('layer-mask').addEventListener('mousedown', e=>{
    const {x,y} = getXY(e);
    if (y < TOPBAR_H || y > H - TRAY_H) return;
    tryCollect(x, y);
  });
}

window.addEventListener('resize', ()=>{ resize(); getCtxs(); makeSandNoise(); });

initGame();
loop();
</script>
</body>
</html>

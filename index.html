<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>çŒ«ç ‚æ·˜æ·˜ä¹</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1208;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100dvh;
    overflow: hidden;
    font-family: 'Segoe UI', sans-serif;
    touch-action: none;
    user-select: none;
  }

  #game-wrapper {
    position: relative;
    width: min(400px, 100vw);
    height: min(700px, 100dvh);
    background: #2c1f0e;
    border-radius: 24px;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(0,0,0,0.8);
  }

  #canvas-bg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  #game-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }

  #litter-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 3;
    pointer-events: none;
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    z-index: 10;
    padding: 12px 16px 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(to bottom, rgba(26,18,8,0.9) 60%, transparent);
  }

  #score-display {
    font-size: 22px;
    font-weight: 800;
    color: #f5c842;
    text-shadow: 0 2px 8px rgba(245,200,66,0.4);
    letter-spacing: 1px;
  }
  #score-label { font-size: 10px; color: #a07040; font-weight: 600; letter-spacing: 2px; }

  #shake-hint {
    font-size: 11px;
    color: #c8a060;
    text-align: center;
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse { 0%,100%{opacity:.5} 50%{opacity:1} }

  #combo-display {
    font-size: 13px;
    color: #ff8844;
    font-weight: 700;
    min-width: 60px;
    text-align: right;
  }

  /* TRAY */
  #tray-area {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    z-index: 10;
    padding: 10px 10px 16px;
    background: linear-gradient(to top, rgba(20,12,4,0.97) 70%, transparent);
  }

  #tray-label {
    font-size: 9px;
    color: #6b4820;
    letter-spacing: 3px;
    text-align: center;
    margin-bottom: 6px;
    font-weight: 700;
  }

  #slots {
    display: flex;
    gap: 5px;
    justify-content: center;
  }

  .slot {
    width: 46px;
    height: 54px;
    border-radius: 10px;
    background: rgba(255,255,255,0.04);
    border: 1.5px solid rgba(255,255,255,0.08);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    position: relative;
    transition: background 0.2s;
    flex-shrink: 0;
  }

  .slot.occupied { background: rgba(255,255,255,0.08); }
  .slot.flash {
    animation: slotflash 0.3s ease;
  }
  @keyframes slotflash {
    0%{background:rgba(255,200,50,0.5);transform:scale(1.1)}
    100%{background:rgba(255,255,255,0.08);transform:scale(1)}
  }

  .slot-emoji {
    font-size: 26px;
    animation: slotIn 0.25s cubic-bezier(.17,.67,.35,1.4);
  }
  @keyframes slotIn {
    0%{transform:scale(0) rotate(-20deg);opacity:0}
    100%{transform:scale(1) rotate(0deg);opacity:1}
  }

  /* OVERLAY TEXTS */
  .floating-text {
    position: absolute;
    z-index: 20;
    font-weight: 900;
    pointer-events: none;
    animation: floatUp 0.9s ease forwards;
    white-space: nowrap;
  }
  @keyframes floatUp {
    0%{transform:translateY(0) scale(1);opacity:1}
    100%{transform:translateY(-80px) scale(1.4);opacity:0}
  }

  #match-burst {
    position: absolute;
    z-index: 20;
    pointer-events: none;
    font-size: 28px;
    font-weight: 900;
    text-align: center;
    display: none;
    animation: burstPop 0.6s cubic-bezier(.17,.67,.35,1.4) forwards;
  }
  @keyframes burstPop {
    0%{transform:scale(0);opacity:0}
    50%{transform:scale(1.3);opacity:1}
    100%{transform:scale(1);opacity:0}
  }

  /* GAME OVER */
  #gameover {
    position: absolute;
    inset: 0;
    z-index: 50;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(4px);
  }
  #gameover.show { display: flex; }
  #gameover h1 { font-size: 36px; color: #f5c842; margin-bottom: 8px; }
  #gameover p { color: #c8a060; font-size: 16px; margin-bottom: 24px; }
  #restart-btn {
    padding: 14px 36px;
    background: #f5c842;
    color: #1a1208;
    border: none;
    border-radius: 50px;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    letter-spacing: 1px;
  }

  /* SHAKE RIPPLE */
  #shake-ripple {
    position: absolute;
    inset: 0;
    z-index: 15;
    pointer-events: none;
    border-radius: 24px;
    opacity: 0;
    border: 3px solid rgba(245,200,66,0.6);
    transition: opacity 0.3s;
  }
  #shake-ripple.active {
    opacity: 1;
    animation: rippleFlash 0.4s ease;
  }
  @keyframes rippleFlash {
    0%{opacity:0.8;box-shadow:inset 0 0 30px rgba(245,200,66,0.3)}
    100%{opacity:0}
  }
</style>
</head>
<body>

<div id="game-wrapper">
  <canvas id="canvas-bg"></canvas>
  <canvas id="game-canvas"></canvas>
  <canvas id="litter-canvas"></canvas>

  <div id="hud">
    <div>
      <div id="score-label">SCORE</div>
      <div id="score-display">0</div>
    </div>
    <div id="shake-hint">ğŸ‘† å¿«é€Ÿç‚¹å‡»å±å¹•<br>è®©çŒ«ç ‚ç¿»æ»šï¼</div>
    <div id="combo-display"></div>
  </div>

  <div id="tray-area">
    <div id="tray-label">æ”¶é›†æ§½ Â· 7 SLOTS</div>
    <div id="slots"></div>
  </div>

  <div id="shake-ripple"></div>
  <div id="match-burst"></div>

  <div id="gameover">
    <h1>ğŸ’© æ§½ä½å·²æ»¡ï¼</h1>
    <p id="final-score">æœ€ç»ˆå¾—åˆ†: 0</p>
    <button id="restart-btn" onclick="initGame()">å†æ¥ä¸€å±€ ğŸ”„</button>
  </div>
</div>

<script>
// â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TURD_TYPES = [
  { id: 0, emoji: 'ğŸ’©', color: '#8B4513', label: 'æ™®é€šä¾¿' },
  { id: 1, emoji: 'ğŸŸ¤', color: '#A0522D', label: 'åœ†çƒä¾¿' },
  { id: 2, emoji: 'ğŸ«˜', color: '#6B3A2A', label: 'è±†è±†ä¾¿' },
  { id: 3, emoji: 'âš«', color: '#3D2B1F', label: 'é»‘ä¾¿' },
  { id: 4, emoji: 'ğŸŸ¡', color: '#C8A030', label: 'é‡‘ä¾¿' },
];

const TURD_EMOJIS = ['ğŸ’©','ğŸŸ¤','ğŸ«˜','âš«','â­'];
const TURD_COLORS = ['#c17f3b','#a05030','#7a4030','#4a3828','#d4a82a'];
const MAX_SLOTS = 7;
const TURD_COUNT = 18;
const SHAKE_THRESHOLD = 6; // taps in window to trigger
const SHAKE_WINDOW = 600; // ms

// â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let engine, render, runner;
let turds = [];
let slots = []; // array of turd type ids (-1 = empty)
let score = 0;
let combo = 0;
let gameOver = false;
let tapTimes = [];
let litterPhase = 0;
let animFrame;
let W, H;

// â”€â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const wrapper = document.getElementById('game-wrapper');
const gameCanvas = document.getElementById('game-canvas');
const litterCanvas = document.getElementById('litter-canvas');
const bgCanvas = document.getElementById('canvas-bg');
const slotsEl = document.getElementById('slots');
const scoreEl = document.getElementById('score-display');
const comboEl = document.getElementById('combo-display');
const matchBurst = document.getElementById('match-burst');
const shakeRipple = document.getElementById('shake-ripple');

// â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize() {
  W = wrapper.clientWidth;
  H = wrapper.clientHeight;
  gameCanvas.width = W;
  gameCanvas.height = H;
  litterCanvas.width = W;
  litterCanvas.height = H;
  bgCanvas.width = W;
  bgCanvas.height = H;
}

// â”€â”€â”€ BACKGROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBackground() {
  const ctx = bgCanvas.getContext('2d');
  ctx.fillStyle = '#1e1208';
  ctx.fillRect(0, 0, W, H);
  // Vignette
  const grad = ctx.createRadialGradient(W/2, H/2, H*0.1, W/2, H/2, H*0.8);
  grad.addColorStop(0, 'rgba(44,31,14,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.7)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

// â”€â”€â”€ PHYSICS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupPhysics() {
  if (engine) Matter.Runner.stop(runner);

  engine = Matter.Engine.create({ gravity: { x: 0, y: 1.2 } });
  runner = Matter.Runner.create();

  // Walls
  const walls = [
    Matter.Bodies.rectangle(W/2, H + 30, W + 60, 60, { isStatic: true, label: 'wall' }),
    Matter.Bodies.rectangle(-30, H/2, 60, H + 60, { isStatic: true, label: 'wall' }),
    Matter.Bodies.rectangle(W + 30, H/2, 60, H + 60, { isStatic: true, label: 'wall' }),
  ];

  // Ceiling well below litter surface
  const ceiling = Matter.Bodies.rectangle(W/2, -30, W + 60, 60, { isStatic: true, label: 'wall' });

  Matter.World.add(engine.world, [...walls, ceiling]);
  Matter.Runner.run(runner, engine);
}

// â”€â”€â”€ CREATE TURDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createTurds() {
  turds = [];
  const trayH = 90;
  const spawnZone = H - trayH - 40;

  for (let i = 0; i < TURD_COUNT; i++) {
    const typeId = i % TURD_TYPES.length;
    const x = 30 + Math.random() * (W - 60);
    const y = spawnZone * 0.4 + Math.random() * (spawnZone * 0.5);
    const r = 14 + Math.random() * 6;

    const body = Matter.Bodies.circle(x, y, r, {
      restitution: 0.4,
      friction: 0.3,
      frictionAir: 0.08,
      density: 0.002,
      label: 'turd',
      collisionFilter: { category: 0x0002, mask: 0x0002 | 0x0001 }
    });
    body.typeId = typeId;
    body.turdIndex = i;
    body.radius = r;
    body.collected = false;
    body.buried = true; // starts buried

    Matter.World.add(engine.world, body);
    turds.push(body);
  }
}

// â”€â”€â”€ LITTER CANVAS (animated sand mask) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let litterNoise = [];
function initLitter() {
  litterNoise = [];
  const cols = 40;
  for (let i = 0; i <= cols; i++) {
    litterNoise.push(Math.random() * Math.PI * 2);
  }
}

function drawLitter(ctx, phase) {
  const trayH = 88;
  const litterTop = H * 0.12;
  const litterBot = H - trayH;
  const cols = litterNoise.length - 1;
  const colW = W / cols;

  ctx.clearRect(0, 0, W, H);

  // Sand fill
  const sandGrad = ctx.createLinearGradient(0, litterTop, 0, litterBot);
  sandGrad.addColorStop(0, 'rgba(180,140,80,0.95)');
  sandGrad.addColorStop(0.3, 'rgba(160,118,60,0.98)');
  sandGrad.addColorStop(1, 'rgba(120,85,40,0.99)');

  ctx.beginPath();
  // Wavy top surface
  const waveAmp = 5;
  ctx.moveTo(0, litterBot);
  ctx.lineTo(0, litterTop + waveAmp);
  for (let i = 0; i <= cols; i++) {
    const nx = i * colW;
    const wave = Math.sin(litterNoise[i] + phase) * waveAmp
               + Math.sin(litterNoise[i] * 0.5 + phase * 0.7) * 3;
    ctx.lineTo(nx, litterTop + wave);
  }
  ctx.lineTo(W, litterBot);
  ctx.closePath();
  ctx.fillStyle = sandGrad;
  ctx.fill();

  // Grain texture
  ctx.save();
  ctx.globalAlpha = 0.18;
  for (let gy = litterTop; gy < litterBot; gy += 6) {
    for (let gx = 0; gx < W; gx += 5) {
      const shade = Math.random() > 0.5 ? 'rgba(255,220,130,0.6)' : 'rgba(80,50,20,0.4)';
      ctx.fillStyle = shade;
      ctx.fillRect(gx + Math.random()*3, gy + Math.random()*3, 2, 2);
    }
  }
  ctx.restore();

  // Top highlight
  ctx.save();
  ctx.globalAlpha = 0.25;
  const hGrad = ctx.createLinearGradient(0, litterTop - 5, 0, litterTop + 20);
  hGrad.addColorStop(0, 'rgba(255,230,160,0.8)');
  hGrad.addColorStop(1, 'rgba(255,230,160,0)');
  ctx.fillStyle = hGrad;
  ctx.fillRect(0, litterTop - 5, W, 30);
  ctx.restore();
}

// â”€â”€â”€ GAME CANVAS (turds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTurds(ctx) {
  const trayH = 88;
  const litterTop = H * 0.12;

  ctx.clearRect(0, 0, W, H);

  for (const t of turds) {
    if (t.collected) continue;

    const { x, y } = t.position;
    const r = t.radius;
    const typeId = t.typeId;
    const color = TURD_COLORS[typeId];

    // Only show if peeking above litter or surfaced
    const surfaceY = litterTop;
    const buriedDepth = surfaceY + 20;

    // Determine visibility: turds above litter surface are visible
    if (y + r < buriedDepth && t.buried) continue;
    if (y > H - trayH - 10) continue; // in tray zone

    // Glow for surfaced turds
    const isSurfaced = y < litterTop + 30;
    if (isSurfaced) {
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = 18;
    }

    // Body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(t.angle || 0);

    // Shadow
    ctx.beginPath();
    ctx.ellipse(2, 3, r * 1.1, r * 0.85, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fill();

    // Main body gradient
    const grad = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.1, 0, 0, r);
    grad.addColorStop(0, lighten(color, 40));
    grad.addColorStop(0.6, color);
    grad.addColorStop(1, darken(color, 30));

    ctx.beginPath();
    if (typeId === 0) drawPoop(ctx, r);
    else if (typeId === 1) ctx.arc(0, 0, r, 0, Math.PI * 2);
    else if (typeId === 2) drawBean(ctx, r);
    else if (typeId === 3) drawNugget(ctx, r);
    else drawStar(ctx, r);

    ctx.fillStyle = grad;
    ctx.fill();

    // Shine
    ctx.beginPath();
    ctx.ellipse(-r*0.25, -r*0.3, r*0.3, r*0.2, -0.5, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();

    // Emoji label
    ctx.font = `${r * 0.9}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha = 0.7;
    ctx.fillText(TURD_EMOJIS[typeId], 0, 0);
    ctx.globalAlpha = 1;

    ctx.restore();
    if (isSurfaced) ctx.restore();
  }
}

// Poop silhouette
function drawPoop(ctx, r) {
  ctx.moveTo(0, r);
  ctx.bezierCurveTo(r, r, r*1.1, 0, r*0.5, -r*0.3);
  ctx.bezierCurveTo(r*0.9, -r*0.6, r*0.5, -r*1.1, 0, -r);
  ctx.bezierCurveTo(-r*0.5, -r*1.1, -r*0.9, -r*0.6, -r*0.5, -r*0.3);
  ctx.bezierCurveTo(-r*1.1, 0, -r, r, 0, r);
}
function drawBean(ctx, r) {
  ctx.ellipse(0, 0, r*0.7, r, 0.3, 0, Math.PI*2);
}
function drawNugget(ctx, r) {
  ctx.moveTo(0, -r);
  for (let i = 0; i < 6; i++) {
    const a = (i / 6) * Math.PI * 2 - Math.PI / 2;
    const ir = r * (0.7 + Math.sin(i * 2.1) * 0.2);
    ctx.lineTo(Math.cos(a) * ir, Math.sin(a) * ir);
  }
  ctx.closePath();
}
function drawStar(ctx, r) {
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
    const ia = a + Math.PI / 5;
    if (i === 0) ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
    else ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    ctx.lineTo(Math.cos(ia)*r*0.45, Math.sin(ia)*r*0.45);
  }
  ctx.closePath();
}

function lighten(hex, amt) {
  const r = Math.min(255, parseInt(hex.slice(1,3),16)+amt);
  const g = Math.min(255, parseInt(hex.slice(3,5),16)+amt);
  const b = Math.min(255, parseInt(hex.slice(5,7),16)+amt);
  return `rgb(${r},${g},${b})`;
}
function darken(hex, amt) {
  const r = Math.max(0, parseInt(hex.slice(1,3),16)-amt);
  const g = Math.max(0, parseInt(hex.slice(3,5),16)-amt);
  const b = Math.max(0, parseInt(hex.slice(5,7),16)-amt);
  return `rgb(${r},${g},${b})`;
}

// â”€â”€â”€ SLOTS RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSlots() {
  slotsEl.innerHTML = '';
  for (let i = 0; i < MAX_SLOTS; i++) {
    const div = document.createElement('div');
    div.className = 'slot' + (slots[i] !== undefined ? ' occupied' : '');
    if (slots[i] !== undefined) {
      const span = document.createElement('span');
      span.className = 'slot-emoji';
      span.textContent = TURD_EMOJIS[slots[i]];
      div.appendChild(span);
    }
    slotsEl.appendChild(div);
  }
}

// â”€â”€â”€ SHAKE / SIFT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function registerTap(x, y) {
  if (gameOver) return;

  const now = Date.now();
  tapTimes = tapTimes.filter(t => now - t < SHAKE_WINDOW);
  tapTimes.push(now);

  if (tapTimes.length >= SHAKE_THRESHOLD) {
    triggerSift();
    tapTimes = [];
  } else {
    // Single gentle nudge
    gentleNudge();
  }
}

function triggerSift() {
  // Flash rim
  shakeRipple.classList.remove('active');
  void shakeRipple.offsetWidth;
  shakeRipple.classList.add('active');

  const trayH = 88;
  const litterTop = H * 0.12;

  // Apply upward force to buried turds
  for (const t of turds) {
    if (t.collected) continue;
    const { x, y } = t.position;
    if (y < H - trayH) {
      const fx = (Math.random() - 0.5) * 0.06;
      const fy = -(0.04 + Math.random() * 0.06);
      Matter.Body.applyForce(t, t.position, { x: fx, y: fy });
      Matter.Body.setAngularVelocity(t, (Math.random() - 0.5) * 0.3);
      if (y < litterTop + 40) t.buried = false;
    }
  }

  // Update litter phase faster
  litterPhase += 0.8;
  if (navigator.vibrate) navigator.vibrate(30);
}

function gentleNudge() {
  const trayH = 88;
  for (const t of turds) {
    if (t.collected) continue;
    if (t.position.y < H - trayH) {
      Matter.Body.applyForce(t, t.position, {
        x: (Math.random() - 0.5) * 0.008,
        y: -(0.005 + Math.random() * 0.01)
      });
    }
  }
}

// â”€â”€â”€ CLICK / TAP COLLECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tryCollect(screenX, screenY) {
  if (gameOver) return;

  const trayH = 88;
  const litterTop = H * 0.12;

  // Check hit radius (generous)
  let best = null;
  let bestDist = 999;

  for (const t of turds) {
    if (t.collected || t.buried) continue;
    const { x, y } = t.position;
    if (y > H - trayH) continue; // in tray zone

    const dist = Math.hypot(x - screenX, y - screenY);
    const hitR = t.radius * 1.8; // generous hit area
    if (dist < hitR && dist < bestDist) {
      best = t;
      bestDist = dist;
    }
  }

  if (best) collectTurd(best, screenX, screenY);
}

function collectTurd(t, sx, sy) {
  t.collected = true;
  Matter.Body.setStatic(t, true);

  // Add to slots
  if (slots.length >= MAX_SLOTS) {
    triggerGameOver();
    return;
  }

  slots.push(t.typeId);
  renderSlots();

  // Floating +1 text
  spawnFloatText(sx, sy, '+1', '#f5c842', 16);

  // Check match
  checkMatch();
  if (navigator.vibrate) navigator.vibrate(15);
}

function checkMatch() {
  // Count each type
  const counts = {};
  for (const id of slots) {
    counts[id] = (counts[id] || 0) + 1;
  }

  for (const [id, count] of Object.entries(counts)) {
    if (count >= 3) {
      // Remove 3 of this type
      let removed = 0;
      slots = slots.filter(s => {
        if (s === parseInt(id) && removed < 3) { removed++; return false; }
        return true;
      });

      combo++;
      const points = 100 * combo;
      score += points;
      scoreEl.textContent = score;
      comboEl.textContent = combo > 1 ? `x${combo} è¿æ¶ˆ!` : '';

      // Burst text
      showMatchBurst(TURD_EMOJIS[parseInt(id)], points);

      if (navigator.vibrate) navigator.vibrate([30, 20, 60]);

      renderSlots();
      flashSlots();
      spawnParticles(W/2, H - 120, TURD_COLORS[parseInt(id)]);

      // Check again (cascade)
      setTimeout(checkMatch, 200);
      return;
    }
  }
  // No match
  if (slots.length < MAX_SLOTS) combo = Math.max(0, combo - 1);
  comboEl.textContent = combo > 1 ? `x${combo} è¿æ¶ˆ!` : '';
}

function flashSlots() {
  document.querySelectorAll('.slot').forEach(s => {
    s.classList.remove('flash');
    void s.offsetWidth;
    s.classList.add('flash');
  });
}

// â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let particles = [];
function spawnParticles(x, y, color) {
  for (let i = 0; i < 20; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: -(2 + Math.random() * 5),
      life: 1,
      color,
      r: 3 + Math.random() * 4,
    });
  }
}

function drawParticles(ctx) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life -= 0.03;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// â”€â”€â”€ FLOATING TEXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnFloatText(x, y, text, color, size) {
  const el = document.createElement('div');
  el.className = 'floating-text';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.color = color;
  el.style.fontSize = size + 'px';
  el.textContent = text;
  wrapper.appendChild(el);
  setTimeout(() => el.remove(), 900);
}

function showMatchBurst(emoji, pts) {
  matchBurst.style.display = 'block';
  matchBurst.style.left = W/2 - 80 + 'px';
  matchBurst.style.top = H/2 - 60 + 'px';
  matchBurst.textContent = `${emoji}Ã—3  +${pts}`;
  matchBurst.style.color = '#f5c842';
  matchBurst.style.textShadow = '0 0 20px rgba(245,200,66,0.8)';
  matchBurst.style.animation = 'none';
  void matchBurst.offsetWidth;
  matchBurst.style.animation = 'burstPop 0.8s cubic-bezier(.17,.67,.35,1.4) forwards';
  setTimeout(() => { matchBurst.style.display = 'none'; }, 900);
}

// â”€â”€â”€ GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerGameOver() {
  gameOver = true;
  document.getElementById('gameover').classList.add('show');
  document.getElementById('final-score').textContent = `æœ€ç»ˆå¾—åˆ†: ${score}`;
}

// â”€â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTapTime = 0;
let tapCount = 0;

gameCanvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const rect = gameCanvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;

  registerTap(x, y);

  // Also try to collect if turd is near tap
  tryCollect(x, y);
}, { passive: false });

gameCanvas.addEventListener('click', e => {
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  registerTap(x, y);
  tryCollect(x, y);
});

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop() {
  animFrame = requestAnimationFrame(gameLoop);
  litterPhase += 0.012;

  const gCtx = gameCanvas.getContext('2d');
  const lCtx = litterCanvas.getContext('2d');

  // Draw turds (below litter)
  drawTurds(gCtx);

  // Draw litter mask (on top)
  drawLitter(lCtx, litterPhase);

  // Draw particles on top of litter (on game canvas? use litter canvas)
  drawParticles(gCtx);

  // Keep turds in bounds & update burial state
  const trayH = 88;
  const litterTop = H * 0.12;
  for (const t of turds) {
    if (t.collected) continue;
    const { x, y } = t.position;
    // Clamp horizontal
    if (x < t.radius) Matter.Body.setPosition(t, { x: t.radius + 1, y });
    if (x > W - t.radius) Matter.Body.setPosition(t, { x: W - t.radius - 1, y });
    // Floor above tray
    const floor = H - trayH - t.radius;
    if (y > floor) Matter.Body.setPosition(t, { x, y: floor });

    // Update burial state based on position
    if (y < litterTop + 15 && !t.collected) t.buried = false;
  }
}

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initGame() {
  document.getElementById('gameover').classList.remove('show');
  gameOver = false;
  slots = [];
  score = 0;
  combo = 0;
  particles = [];
  tapTimes = [];
  scoreEl.textContent = '0';
  comboEl.textContent = '';

  if (animFrame) cancelAnimationFrame(animFrame);
  Matter.World.clear(engine?.world || {});

  resize();
  drawBackground();
  setupPhysics();
  createTurds();
  initLitter();
  renderSlots();
  gameLoop();

  // Initial gentle sift after 1s
  setTimeout(() => {
    for (let i = 0; i < 3; i++) setTimeout(triggerSift, i * 300);
  }, 800);
}

window.addEventListener('resize', () => {
  resize();
  drawBackground();
});

initGame();
</script>
</body>
</html>
